#!/bin/env python
# 
#  Finds largest unmounted AWS/Openstack ephemeral storage device (disk
#  or existing partition, formats it,  mounts it as /home, and copies 
#  current contents of /home to it. 
#
#  Gathers partition information from 'lsblk -b'
#  Eliminate / partition from candidates
#  Exit if /home is already mounted as a separate partition
#  


import logging
import os
import subprocess
import sys
import time
import urllib

# Globals
logfile="/var/log/mounthome.log"
log = None

class BlockDevice(object):
    
    def __init__(self):
        self.has_lvm = False

    def __str__(self):
        s = "BlockDevice: "
        attrs = vars(self)
        s += ', '.join("%s=%s" % item for item in attrs.items())
        return s
    
    def __repr__(self):
        return "%s" % self
        

class PartInfo(object):

    def __init__(self, fields):
        # Parameter is list of fields from 'lsblk -bl' output...
        #print ("length: %s" % len(fields))
        self.name = fields[0]
        maj,min = fields[1].split(':')
        self.maj = maj
        self.min = min
        self.rm = fields[2]
        self.size = fields[3]
        self.ro = fields[4]
        self.type = fields[5]
        if len(fields) == 7: 
            self.mount = fields[6]
        else:
            self.mount = None

    def __str__(self):
        return "Partinfo: %s %s:%s %s %s %s %s %s" % (self.name,
                                                      self.maj,
                                                      self.min,
                                                      self.rm,
                                                      self.size,
                                                      self.ro,
                                                      self.type,
                                                      self.mount)

def setuplogging():
    global log
    
    # Set up logging. 
    # Check python version 
    major, minor, release, st, num = sys.version_info
    
    # Set up logging, handle differences between Python versions... 
    # In Python 2.3, logging.basicConfig takes no args
    #
    FORMAT23="[ %(levelname)s ] %(asctime)s %(filename)s (Line %(lineno)d): %(message)s"
    FORMAT24=FORMAT23
    FORMAT25="[%(levelname)s] %(asctime)s %(module)s.%(funcName)s(): %(message)s"
    FORMAT26=FORMAT25
    
    if major == 2:
        if minor ==3:
            formatstr = FORMAT23
        elif minor == 4:
            formatstr = FORMAT24
        elif minor == 5:
            formatstr = FORMAT25
        elif minor == 6:
            formatstr = FORMAT26
    log = logging.getLogger()    
    hdlr = logging.StreamHandler(sys.stdout)
    formatter = logging.Formatter(FORMAT23)
    hdlr.setFormatter(formatter)
    log.addHandler(hdlr)
    # Handle file-based logging.
    if logfile:
        hdlr = logging.FileHandler(logfile)
        hdlr.setFormatter(formatter)
        log.addHandler(hdlr)
    log.setLevel(logging.DEBUG)

def mounthome():
    global log
    log.debug("Getting block device info...")
    blockdevs = getblockinfo()
    log.debug("Got %d blockdevs: %s" % (len(blockdevs),blockdevs ) )
    log.debug("Adding/checking lvm entries...")
    blockdevs = checklvm(blockdevs)
    log.debug("Selecting candidate.")
    best = selectdevice(blockdevs)
    if best:
        log.info("Found candidate. Handling...")
        #formatdisk(best)
        #movemountmirror(best)
        log.info("Done")

def getpartitions():
    global log
    cmd = 'lsblk -nbr'
    out = runtimedcommand(cmd)
    lines = out.split("\n")
    parts = []
    for line in lines:
        fields = line.split()
        if len(fields) > 5:
            p = PartInfo(fields)
            parts.append(p)
    for p in parts:
        print(p)
    return parts    


def getblockinfo():
    global log
    cmd = 'lsblk -nbP'
    out = runtimedcommand(cmd)
    log.debug("out is %s" % out)
    lines = out.split("\n")
    log.debug("got %d lines" % len(lines))
    blockdevs = []
    for line in lines:

        #log.debug("Creating block device for line %s" % line)
        bd = BlockDevice()
        fields = line.split()
        for field in fields:
            (key,val) = field.split('=')
            key = key.lower().strip()
            #log.debug("Handling key %s" % key)
            val = val.replace('"', '')
            if len(val) == 0:
                #log.debug("Found empty val for %s, setting to None" % key)
                val = None
            try:
                intval = int(val)
                #log.debug("Found integer value for %s, setting." % key)
                val = intval
            except:
                pass
            #log.debug("Setting attribute %s to %s" % (key, val))
            setattr(bd, key, val)
        
        if bd.type != "lvm":
            blockdevs.append(bd)
        else:
            log.debug("Ignoring LVM block device %s" % bd.name)
    return blockdevs


def checklvm(devlist):
    #
    # runs pvdisplay and sets has_lvm to True on block devices with
    # LVM volumes on them...
    #
    global log
    cmd = 'pvdisplay -c'
    out = runtimedcommand(cmd)
    lines = out.split("\n")
    for line in lines:
        fields = line.split(':')
        log.debug("LVM device name is %s" % fields[0])
    return devlist
  
  
def selectdevice(devlist):
    plist = devlist
    log.debug("Got list of %s block device objects" % len(plist))
    # ? /home already separate?
    for p in plist:
        if p.mountpoint == "/home":
            log.info("/home already mounted: %s" % p.name)
            return None
    # Select from only partitions marked 'part' that are currently unmounted...
    candidates = []
    for p in plist:
        if p.type == "part" or p.type == "disk":
            if p.mountpoint is None:
                candidates.append(p)
    if len(candidates) < 1:
        log.info("No unmounted partitions/disks.")
        return None
    log.debug("Got list of %s unmounted regular partitions" % len(candidates))
    #for c in candidates:
    #    print(c)
    # Choose largest unmounted partition
    from operator import attrgetter
    candidates.sort(key=attrgetter('size'), reverse=False)
    log.debug("Sorting list of partitions by size...")
    #for c in candidates:
    #    print(c)    
    best = candidates[0]
    log.info("Found candidate for /home: %s" % best )
    return best
    
def formatdisk(pinfo):
    # mkfs.ext3 -F -L home /dev/$VD
    devname = "/dev/%s" % pinfo.name
    cmd = "mkfs.ext3 -F -L home %s" % devname
    runtimedcommand(cmd)
    
def movemountmirror(pinfo):
    # mv -v /home /home.orig >> $LOGFILE  2>&1
    #            mkdir -v /home >> $LOGFILE  2>&1
    #            mount -t ext3 /dev/$VD /home >> $LOGFILE  2>&1
    #            cp -avr /home.orig/* /home   >> $LOGFILE  2>&1
    devname = "/dev/%s" % pinfo.name    
    if not os.path.isdir("/home.orig"):  
        os.rename("/home", "/home.orig")
    # If there is /home.orig, it means mounthome has run before, and the node has rebooted. 
    # So it may no longer have the original ephemeral partion. 
    # So we want to mount and re-populate.
    try:
        os.mkdir("/home")
    except OSError:
        pass    
    log.info("Mounting %s at /home..." % devname)
    cmd = 'mount -t ext3 %s /home' % devname
    runtimedcommand(cmd)
    
    log.info("Copying content from")
    cmd = "cp -avr /home.orig/* /home"
    runtimedcommand(cmd)
    log.info("Done.")    
        

def runtimedcommand(command):
    global log
    before = time.time()
    log.info("Running command: '%s'" % command)
    p = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
    out = None
    (out, err) = p.communicate()
    delta = time.time() - before
    log.info("Command took %d seconds." % delta)
    out = out.strip()
    err = err.strip()
    if p.returncode != 0:
        log.debug("Output: %s" % out)
        log.debug("Error: %s" % err)
        return None  
    else:
        log.debug("Command returned OK.")
        return out
	
	
if __name__ == '__main__':
    setuplogging()
    mounthome()
   
